---
title: "sealevelmonitor"
author: "Willem Stolte, Fedor Baart"
date: "2024-03-12"
output:
  html_document:
    df_print: paged
    code_folding: hide
  html_notebook:
    code_folding: hide
params:
  wind_or_surge_type: GTSM
  station:
  # - Delfzijl
  # - Harlingen
  # - Den Helder
  # - IJmuiden
  # - Hoek van Holland
  # - Vlissingen
  # - Netherlands
  - Netherlands (without Delfzijl)
  modeltype:
  - linear
  # - broken_linear
#  - broken_linear
#  - broken_squared
---


```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = TRUE,
  comment=FALSE,
  message=FALSE
)

require(leaflet)
require(plotly)
require(nlme)

config <- RcppTOML::parseToml("_common/configuration.TOML")
source("_common/functions.R")
source("_common/plotfunctions.R")
epoch = config$constants$epoch
mainstations_df <- readMainStationInfo()
mainstations_locs <- readMainStationLocations()
nstations = length(params$station)
nmodels  = length(params$modeltype)
nsurge  = length(params$wind_or_surge_type)

```

## Gegevens inlezen

Maandelijks en jaarlijks gemiddelde waterhoogtegegevens zijn beschikbaar via [PSMSL](https://psmsl.org/data/obtaining/). Deze gegevens worden ingelezen. 

!!!!! Onderstaand vervangen door inlezen van origineel gedownloade data 
- psmsl
- gtsm
- wind heranalyses


```{r readData, comment=F, message=F}

df <- readSeaLevelData(config$constants$dataUrl) %>%
  mutate(epoch = epoch) %>%
  addSurgeAnomaly() %>%
  addBreakPoints() %>%
  selectCols() %>%
  filter(
    station %in% params$station
  ) %>%
  filter(year<= 2021)

```

## Locaties van de Nederlandse hoofdstations

Dit document rapporteert over een selectie van de Nederlandse getijstations. Er is een keuze gemaakt op basis van geografissche spreiding en lengte van de beschikbare tijdseries. 

```{r selected-stations, fig.cap="Hoofdgetijstations in Nederland. Er is aangegeven welke stations zijn meegenomen in dit rekendocument. "}

factpal <- colorFactor(c("red", "darkgreen"), c("selected", "not selected"))

df %>%
  dplyr::distinct(station) %>%
  dplyr::left_join(mainstations_df, by = c(station = "name")) %>%
  dplyr::right_join(mainstations_locs %>% mutate(ID = as.character(ID)), by = c(id = "ID")) %>%
  mutate(`selected stations` = ifelse(!is.na(location), "selected", "not selected")) %>%
  leaflet::leaflet() %>%
  leaflet::addTiles() %>%
  leaflet::addCircleMarkers(
    lat = ~Lat, 
    lng = ~Lon, 
    color = ~ factpal(`selected stations`),
    label = ~ location,
    labelOptions = labelOptions(noHide = T)) %>%
  leaflet::setView(lng = mean(mainstations_locs$Lon), lat = mean(mainstations_locs$Lat), zoom = 6) %>%
  leaflet::addLegend("topleft", pal = factpal, values = ~`selected stations`)
```



To do

-   read NCEP and other wind reanalysis data
-   loop over all wind/surge correction options (?)


```{r nest-per-station}
byStation <- df %>%
  dplyr::group_by(station) %>%
  tidyr::nest() %>%
  dplyr::ungroup()
```


```{r check-workflow}
wind_or_surge_type = params$wind_or_surge_type
check_workflow_wind(wind_or_surge_type = wind_or_surge_type)
```


```{r}

selectedmodel <- params$modeltype
# model_functions_list <- map(paste(selectedmodel, "model", sep = "_"), get)
 
models <- byStation %>%
  # grid extended with model types
  expand_grid(modeltype = selectedmodel) %>%

  
  
  mutate(modelfunctionname = paste(modeltype, "model", sep = "_")) %>%
  # add functions for model calculation
  mutate(modelfunctions = map(modelfunctionname, get)) %>%
  # add models based on data and functions
    mutate(model = pmap(
    list(
      data,
      modelfunctions
    ),
    \(.d, .f) .f(.d)
  )) %>%
  # mutate(
  #   resids = map2(data, model, add_residuals)
  # ) %>%
  # mutate(
  #   preds = map2(data, model, add_predictions)
  # ) %>%
  # add some model characteristics and skill terms
  mutate(
    glance = map(model, broom::glance),
    rsq    = glance %>% map_dbl(~1-.$deviance/.$null.deviance),
    # adj.rsq = glance %>% map_dbl("adj.r.squared"),
    AIC    = glance %>% map_dbl("AIC"),
    tidy   = map(model, broom::tidy),
    augment = map(model, broom::augment),
    equation = map(model, function(x) equatiomatic::extract_eq(x))
  )
```

## Autocorrelation

Autocorrelation

```{r acf-plot, fig.height=nstations*2+1, fig.width=nmodels*3+1, fig.cap="Autocorrelation plot for selected stations and models. "}
models %>%
  mutate(
    ACF = map(augment, function(x) fortify(acf(x$.resid, plot = F)))
  ) %>%
  unnest(ACF) %>%
  mutate(ACF_pass = (ACF >= lower & ACF <= upper)) %>%
  filter(Lag >= 1) %>%
  ggplot(aes(Lag, ACF)) +
  geom_col(width = 0.4, aes(fill = ACF_pass)) +
  geom_vline(xintercept = 8.9, linetype = 3) +
  geom_vline(xintercept = 18.6, linetype = 3) +
  geom_line(aes(y = lower), linetype = "dotdash", linewidth = 0.5) +
  geom_line(aes(y = upper), linetype = "dotdash", linewidth = 0.5) +
  scale_x_continuous(
    breaks = scales::breaks_pretty(10)
    )+
  facet_grid(station ~ modeltype) +
  theme_minimal() +
  theme(
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom"
        )
```
## Heteroskedasticity

### Residuals distribution

```{r, fig.height=nstations*1.5+1, fig.width=nmodels*2+1 }
models %>%
  # filter(!grepl("Netherlands", station)) %>%
  # filter(station == "IJmuiden") %>%
  unnest(c(data, augment), names_sep = "_") %>%
  # str(max.level = 2)
ggplot(aes(x = augment_.resid)) +
  geom_histogram(bins = 20, stat = ) +
  stat_function(fun = dnorm, 
                geom = "line",
                args = list(
                  mean = mean(
                    unnest(models, cols = c(augment), names_sep = "_")$augment_.resid
                    ),
                    sd = sd(
                      unnest(models, cols = c(data, augment), names_sep = "_")$augment_.resid
                    )
                )
  ) +
                  facet_grid(station ~ modeltype) #+

```


## Variation of residuals over time

```{r, fig.height=nstations*1.5+1, fig.width=nmodels*2+1}
models %>%
  # filter(!grepl("Netherlands", station)) %>%
  # filter(station == "IJmuiden") %>%
  unnest(c(data, augment), names_sep = "_") %>% #str(max.level = 2)
ggplot(aes(data_year, augment_.resid)) +
  geom_point(alpha = 0.4) +
  facet_grid(modeltype ~ station) #+
```

## Metingen

```{r, fig.width=8, fig.height=3}
p <- models %>%
  # filter(!grepl("Netherlands", station)) %>%
  # filter(station == "IJmuiden") %>%
  unnest(c(data), names_sep = "_") %>% #str(max.level = 2)
ggplot(aes(data_year, data_height)) +
  geom_point(alpha = 1, aes(color = station), shape = 21, fill = "white", size = 2) +
  geom_line(alpha = 0.5, aes(color = station), linewidth = 0.75) +
  xlab("jaar") + ylab("gemeten zeespiegel in mm") +
  theme_linedraw()

# ggplotly(p) %>% layout(legend = list(x = 0.05, y = 0.95))
p
```


## Sea level rise


```{r}



lookup <- c(
   Constant = "(Intercept)",
    Trend = "I(year - epoch)",
    u_nodal = "I(cos(2 * pi * (year - epoch)/(18.613)))",
    v_nodal = "I(sin(2 * pi * (year - epoch)/(18.613)))",
    `+ trend 1993` = "from1993",
    `+ square_trend 1960` = "from1960_square",
    AR_term = "previousYearHeight"
  )


# data wrangling. move to functions.R

all_predictions <- models %>%
  mutate(
    preds = map2(data, model, add_predictions)
  ) %>%
  dplyr::select(
    station,
    modeltype, 
    data, 
    tidy, 
    preds) %>%
  tidyr::unnest(c(data, preds), names_sep = "_") %>% 
  tidyr::unnest(tidy) %>%
    # str(max.level = 2)

  dplyr::select(-std.error, -statistic, -p.value) %>% # clean up
  tidyr::pivot_wider(
    names_from = term, 
    values_from = estimate
  ) %>%
  mutate(`preds_height-surge anomaly` = preds_pred - `preds_surge anomaly`) %>%
  rename(any_of(lookup)) %>%
  # str(max.level = 2)
  mutate(
    `nodal tide` = 
      u_nodal * cos(2*pi*(data_year-epoch)/18.613) + 
      v_nodal * sin(2*pi*(data_year-epoch)/18.613),
    prediction_recalc = case_when(
      if("linear" %in% params$modeltype){
        modeltype == "linear" ~ 
          Constant + 
          Trend * (data_year - epoch)# + 
          # AR_term * data_previousYearHeight
      },
      if("broken_linear" %in% params$modeltype){
        modeltype == "broken_linear" ~ 
          Constant + 
          Trend * (data_year - epoch) +
          # AR_term * data_previousYearHeight +
          (data_year >= 1993) * `+ trend 1993` * (data_year - 1993)
      },
      # if("broken_quadratic" %in% params$modeltype){
      #   modeltype == "broken_quadratic" ~ Constant + Trend * (data_year - epoch) +
      #     ifelse(data_year >= 1960, from1960_square * (data_year - 1960) * (data_year - 1960), 0)
      # }
    )
    ) %>%
  select(
    station,
    modeltype,
    data_year,
    data_height,
    preds_year,
    prediction_recalc,
    `preds_height-surge anomaly`,
    `nodal tide`
  )

```



```{r prediction-plot, fig.height=nstations*3+1, fig.width=nmodels*3+1, fig.cap= "Observed and predicted sea level for selected stations and models. "}

ggplot(
  all_predictions,
  aes(x = data_year)
) +
  geom_point(aes(y = data_height)) +
  geom_line(aes(y = prediction_recalc)) +
  facet_grid(station ~ modeltype)

```



```{r, eval=FALSE}

if(config$runparameters$stations == "Netherlands (without Delfzijl)"){
  p <- plot_station( 
    predictions_all = all_predictions, 
    correctionVariant = "GTSM", 
    modelVariant = "broken_linear", 
    printNumbers = F)
  
  # ggplotly(p) %>% layout(legend = list(x = 0.05, y = 0.95))
  p
}
```




## Parameters



```{r}

## gebruik DT in plaats van kableextra

lookup.df <- data.frame(long_term = unname(lookup),
                        short_term = names(lookup))

library(DT)

models %>% 
  select(station, modeltype, tidy) %>% 
  unnest(tidy) %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  left_join(lookup.df, by = c(term = "long_term")) %>%
  DT::datatable(
  options = list(
      "digits" = 3
    )
  )

  # kableExtra::kable(
  #   caption = "Coefficients for all models and stations.",digits = 2
  #   ) %>% 
  # kableExtra::scroll_box(height = "500px")




```


```{r}
models %>% 
  unnest(tidy) %>%
  str(max.level = 2)
```



